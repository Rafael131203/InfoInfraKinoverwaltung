# InfoInfraKinoverwaltung
Das Repository dient zur Verwaltung des Codes der Kinoverwaltung, die im Rahmen des Moduls Informationsinfrastrukturen 2 implementiert werden soll.


# Project Overview

This project is built around a modular, scalable, and secure architecture consisting of **five separate C# projects** running inside a **Dockerized environment**.  
It includes **JWT authentication**, **role-based authorization**, **EF Core + PostgreSQL**, **MongoDB**, **Kafka/Redpanda**, **Blazor WebAssembly**, and a strong focus on clean architecture.

---

# KinoApp â€“ Local Development & Running the Project

## Prerequisites

Before running the project, make sure the following tools are installed and available on your system:

* **Docker Desktop** (must be running)
* **.NET SDK** (matching the solution version)
* Visual Studio, Rider, or VS Code (examples below use Visual Studio)

---

## 1. Start the Infrastructure (Docker)

The application depends on several infrastructure services that are provided via Docker containers:

* PostgreSQL (relational database, EF Core migrations)
* MongoDB (statistics & projections)
* Kafka / Redpanda (event messaging)

From the root of the repository, start all containers:

```bash
docker compose up -d
```

On startup, Docker will:

* create all required containers
* apply EF Core database migrations automatically
* seed initial application data

The first startup may take longer than usual due to migrations and seeding.

---

## 2. Application Configuration (Ports & appsettings)

If you change ports or service names in `docker-compose.yml`, you **must** update the corresponding values in the application configuration files.

### Example: Container-to-container configuration

Used when services communicate inside the Docker network:

```json
{
  "ConnectionStrings": {
    "Postgres": "Host=postgres;Port=5432;Database=kinoapp;Username=postgres;Password=postgres"
  },
  "Mongo": "mongodb://mongodb:27017",
  "MongoDatabase": "kino",
  "Kafka": {
    "BootstrapServers": "redpanda:9092",
    "ConsumerGroup": "kinoapp-service"
  }
}
```

### Example: Local development configuration

Used when running the API from Visual Studio and connecting to Docker containers:

```json
{
  "Jwt": {
    "Issuer": "theatre.api",
    "Audience": "theatre.client",
    "SigningKey": "dev-only-please-change-this-key-1234567890"
  },
  "ImdbApi": {
    "BaseUrl": "https://api.imdbapi.dev"
  },
  "ConnectionStrings": {
    "Postgres": "Host=localhost;Port=5432;Database=kinoapp;Username=postgres;Password=postgres"
  },
  "Mongo": "mongodb://localhost:27018",
  "Kafka": {
    "BootstrapServers": "localhost:19092",
    "ConsumerGroup": "kinoapp-service-dev"
  }
}
```

Always verify that:

* database ports match Docker
* MongoDB port matches the exposed container port
* Kafka uses the externally exposed broker port

---

## 3. Running Backend and Web App Together (Visual Studio)

For local development, the backend API and the web frontend should be started together.

### Visual Studio setup

1. Right-click the **solution** â†’ **Properties**
2. Open **Startup Project**
3. Select **Multiple startup projects**
4. Configure:

   * **KinoAppService** â†’ `Start`
   * **KinoAppWeb** â†’ `Start`
5. Apply changes and run the solution

Ensure Docker Desktop is running **before** starting the solution.

---

## 4. First Startup & Data Seeding

During the first run:

* database schema is created or updated
* seed data is inserted automatically

If the UI loads before seeding is finished:

* wait a few seconds
* refresh the browser page

After the initial run, subsequent startups are significantly faster.

---

## Notes & Troubleshooting

* If the API starts but the UI cannot load data:

  * verify Docker containers are healthy
  * check port mappings in `docker-compose.yml`
  * confirm `appsettings*.json` values match Docker ports

* If Kafka is unreachable from the host:

  * ensure you are using the **external** Kafka port (e.g. `localhost:19092`)

* If authentication fails:

  * verify JWT settings are consistent between Service and Web projects

---

## Summary

1. Start Docker containers
2. Verify configuration and ports
3. Run Service + Web as multiple startup projects
4. Wait for initial seeding, then refresh

After these steps, the application should be fully operational.


# 2. Solution Architecture

The system is divided into **five projects**:

### **1. Core**
- Contains domain logic, service methods, mappings, and autogenerated model classes via NMF.
- Contains integration logic for the IMDB API.
- Centralizes business rules for clean maintainability.

### **2. Database (DB)**
- Contains all EF Core **entities**, **mappings**, **repositories**, and **DbContext** logic.
- Stores relational data in **PostgreSQL**.
- Stores analytics/statistics in **MongoDB**.
- Includes DbContextScope & DbContextService to ensure ACID transactions.

### **3. Service**
- Hosts the **Web API**.
- Contains all controllers, JWT token service, appsettings, and Redpanda Kafka consumers.
- Uses **Swagger** for interactive testing and documentation.
- Enforces role-based authorization inside controllers (`User`, `Admin`).

### **4. Shared**
- A shared class library containing DTOs, Enums, and shared models.
- Used by both backend and frontend to maintain consistent data structures.

### **5. Web (Blazor WebAssembly)**
- The front-end of the project.
- Responsible for authentication, routing, layouts, session handling, and permission-based UI rendering.
- Uses UserSession to maintain user state during the session.

---

# 3. Authentication & Security

### **JWT + Refresh Tokens**
- Implements secure login using JWT access tokens and refresh tokens.
- Allows long-lived authentication sessions with minimal risk.
- Access to pages/components is controlled via role checks.

### **Role-Based Authorization**
Controllers use:
- `[Authorize]`
- `[Authorize(Roles = "User")]`
- `[Authorize(Roles = "Admin")]`
- `[AllowAnonymous]`

### **BCrypt Password Encryption**
- Stores all sensitive data safely through BCrypt hashing.
- Adds another security layer to protect usersâ€™ data.

### **App Settings Encapsulation**
- Secrets/configuration stored in *appsettings.json*.
- Injected securely at runtime using dependency injection.

---

# ðŸ—„ 4. Database Layer

### **PostgreSQL Database**
- Used for relational data and all entity-based storage.

### **MongoDB Database**
- Used for storing real-time analytics and statistics.
- Populated by Kafka/Redpanda consumers.

### **Entities & Mappings**
- Each EF Core entity is mapped to a corresponding table and column structure.
- Fluent API ensures strict control over schema.

### **Repository Pattern**
- All repositories inherit from a **BaseRepository** providing:
  - Create  
  - Read  
  - Update  
  - Delete  
- Entity-specific repositories handle advanced queries when needed.

### **DbContextScope & DbContextService**
- Manages all database transactions and ensures ACID compliance.
- Prevents data corruption during multi-step operations.

---

# 5. Service Project (API Layer)

### **API Controllers**
- Enables client communication over REST.
- Powered by **Swagger / OpenAPI** for easy testing and debugging.

### **Redpanda (Kafka) Integration**
- Message broker responsible for gathering analytics.
- Writes consumer results into **MongoDB**.

### **BaseController with Execute()**
- All controllers inherit from a BaseController.
- Uses a central `Execute()` method to:
  - Wrap operations in a DB transaction.
  - Manage DbContextScope.
  - Ensure data integrity and proper error handling.

### **Startup + Program Separation**
- Program.cs â†’ builds host, configures builder  
- Startup.cs â†’ registers services, middleware, authentication, DI  
- Ensures clean separation of concerns

---

# 6. Blazor Web Frontend

### **UserSession**
- Tracks the logged-in user's data.
- Ensures frontend state persists across navigation.
- Updates automatically when roles or tokens change.

### **Routing & Layouts**
- Uses Blazor layouts for reusable UI components.
- Blocks unauthorized pages at route-level.
- Admin-only pages automatically hidden from non-admin users.

### **Role-Based UI Rendering**
- The frontend changes based on:
  - Logged-in status
  - User role
  - Token validity

---

# 7. Core Project (Business Logic)

### **NMF Autogenerated Models**
- Uses the NMF modeling framework to generate C# classes.
- Reduces boilerplate and improves consistency.

### **IMDB API Integration**
- Fetches live data from IMDB for up-to-date information.
- Provides dynamic content for the application.

### **Mappings**
- Converts objects between different layers:
  - Entity â†” Domain Model  
  - Domain Model â†” DTO  

### **Service Folder**
- Holds all business operations abstracted away from controllers.
- Keeps logic clean and testable.

### **CoreServiceExtension**
- Modular registration of all services.
- Startup.cs simply calls `AddCoreServices()`.

---

# 8. Important Methods Used

## **Setup & Running**
- `builder.Build()`
- `builder.Services.AddScoped(...)`
- `Startup.ConfigureServices()`
- `Startup.Configure()`

## **Authentication**
- `GenerateJwtToken()`
- `GenerateRefreshToken()`
- `ValidateRefreshToken()`
- `BCrypt.HashPassword()`
- `BCrypt.Verify()`

## **Database**
- `DbContext.SaveChangesAsync()`
- `DbContextScope.Create()`
- `DbContextService.GetDbContext()`
- CRUD from BaseRepository:
  - `Create()`
  - `Read()`
  - `Update()`
  - `Delete()`
  - `FindAsync()`

## **Kafka**
- `ProduceAsync()`
- `Consume()`
- `DeserializeMessage()`
- `WriteToMongoDb()`

## **Blazor**
- `UserSession.SetUser()`
- `UserSession.Clear()`
- `NavigationManager.NavigateTo()`
- `AuthorizeRouteView`
- `CascadingParameter AuthenticationState`

## **Core**
- `FetchImdbApiData()`
- `ConvertToDto()`
- `ConvertToEntity()`
- Auto-mapping methods
- Domain service workflow methods

---

# Summary

This project combines:

- A **5-layer clean architecture**
- Secure authentication + authorization
- Dockerized environment
- PostgreSQL + MongoDB
- Kafka/Redpanda analytics pipeline
- Blazor WebAssembly frontend
- Strong business logic core
- Modular EF Core data layer
- Consistent DTO/entity/mapping infrastructure

Everything is separated, clean, and scalable.

